<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/2.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/1.png">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":true,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":10,"unescape":false,"preload":false},
    path: './public/search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="教程链接： https://www.liaoxuefeng.com/wiki/896043488029600 🍬. 总结1. 初始化一个Git仓库，使用 &quot;git init&quot; 命令。2. 添加文件到Git仓库，分两步：     - 使用命令 &quot;git add &amp;lt;file&amp;gt;&quot;，注意，可反复多次使用，添加多个文件；     - 使用命令 &quot;git commit -m &amp;lt;messag">
<meta name="keywords" content="Git">
<meta property="og:type" content="article">
<meta property="og:title" content="Git学习">
<meta property="og:url" content="http://yoursite.com/2019/11/10/Gitσ¡ªΣ╣á/index.html">
<meta property="og:site_name" content="各有未来">
<meta property="og:description" content="教程链接： https://www.liaoxuefeng.com/wiki/896043488029600 🍬. 总结1. 初始化一个Git仓库，使用 &quot;git init&quot; 命令。2. 添加文件到Git仓库，分两步：     - 使用命令 &quot;git add &amp;lt;file&amp;gt;&quot;，注意，可反复多次使用，添加多个文件；     - 使用命令 &quot;git commit -m &amp;lt;messag">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/images/git/0.jpg">
<meta property="og:image" content="http://yoursite.com/images/git/1.jpg">
<meta property="og:image" content="http://yoursite.com/images/git/2.jpg">
<meta property="og:image" content="http://yoursite.com/images/git/0.png">
<meta property="og:image" content="http://yoursite.com/images/git/1.png">
<meta property="og:image" content="http://yoursite.com/images/git/2.png">
<meta property="og:image" content="http://yoursite.com/images/git/3.png">
<meta property="og:image" content="http://yoursite.com/images/git/4.png">
<meta property="og:image" content="http://yoursite.com/images/git/5.png">
<meta property="og:image" content="http://yoursite.com/images/git/6.png">
<meta property="og:image" content="http://yoursite.com/images/git/7.png">
<meta property="og:image" content="http://yoursite.com/images/git/8.png">
<meta property="og:image" content="http://yoursite.com/images/git/6.png">
<meta property="og:updated_time" content="2019-11-11T11:07:50.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Git学习">
<meta name="twitter:description" content="教程链接： https://www.liaoxuefeng.com/wiki/896043488029600 🍬. 总结1. 初始化一个Git仓库，使用 &quot;git init&quot; 命令。2. 添加文件到Git仓库，分两步：     - 使用命令 &quot;git add &amp;lt;file&amp;gt;&quot;，注意，可反复多次使用，添加多个文件；     - 使用命令 &quot;git commit -m &amp;lt;messag">
<meta name="twitter:image" content="http://yoursite.com/images/git/0.jpg">

<link rel="canonical" href="http://yoursite.com/2019/11/10/Gitσ¡ªΣ╣á/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Git学习 | 各有未来</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">各有未来</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/10/Gitσ¡ªΣ╣á/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/toux.jpg">
      <meta itemprop="name" content="Alyssa">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="各有未来">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Git学习
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-10 16:25:30" itemprop="dateCreated datePublished" datetime="2019-11-10T16:25:30+08:00">2019-11-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-11 19:07:50" itemprop="dateModified" datetime="2019-11-11T19:07:50+08:00">2019-11-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Git/" itemprop="url" rel="index">
                    <span itemprop="name">Git</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>教程链接： <a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/896043488029600</a> </p><h4 id="🍬-总结"><a href="#🍬-总结" class="headerlink" title="🍬. 总结"></a>🍬. 总结</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. 初始化一个Git仓库，使用 <span class="string">"git init"</span> 命令。</span><br><span class="line">2. 添加文件到Git仓库，分两步：</span><br><span class="line">     - 使用命令 <span class="string">"git add &lt;file&gt;"</span>，注意，可反复多次使用，添加多个文件；</span><br><span class="line">     - 使用命令 <span class="string">"git commit -m &lt;message&gt;"</span>，完成。</span><br><span class="line">3. 要随时掌握工作区的状态，使用 <span class="string">"git status"</span> 命令。</span><br><span class="line">   如果 <span class="string">"git status"</span> 告诉你有文件被修改过，用 <span class="string">"git diff"</span> 可以查看修改内容。</span><br><span class="line">4. 版本回退：</span><br><span class="line">   - HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令 <span class="string">"git reset --hard commit_id"</span>。</span><br><span class="line">   - 穿梭前，用 <span class="string">"git log"</span> 可以查看提交历史，以便确定要回退到哪个版本。</span><br><span class="line">   - 要重返未来，用 <span class="string">"git reflog"</span> 查看命令历史，以便确定要回到未来的哪个版本。</span><br><span class="line">5. 撤销修改：</span><br><span class="line">   - 场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令 <span class="string">"git checkout -- file"</span>。</span><br><span class="line">   - 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令 <span class="string">"git reset HEAD"</span>，就回到了场景1，第二步按场景1操作。</span><br><span class="line">6. 删除文件：</span><br><span class="line">   - 删除一个文件：用命令 <span class="string">"git rm file"</span> 删掉，并且 <span class="string">"git commit -m xxx"</span></span><br><span class="line">   - 恢复误删除文件：<span class="string">"git checkout -- file"</span> 其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。</span><br><span class="line">7. 创建与合并分支：</span><br><span class="line">   - 查看分支：<span class="string">"git branch"</span></span><br><span class="line">   - 创建分支：<span class="string">"git branch &lt;name&gt;"</span></span><br><span class="line">   - 切换分支：<span class="string">"git checkout &lt;name&gt;"</span> 或者 <span class="string">"git switch &lt;name&gt;"</span></span><br><span class="line">   - 创建+切换分支：<span class="string">"git checkout -b &lt;name&gt;"</span> 或者 <span class="string">"git switch -c &lt;name&gt;"</span></span><br><span class="line">   - 合并某分支到当前分支：<span class="string">"git merge &lt;name&gt;"</span></span><br><span class="line">   - 删除分支：<span class="string">"git branch -d &lt;name&gt;"</span></span><br><span class="line">8. 当你当前分支的工作没做完想切换分支的时候，需要把当前分支的内容先隐藏 <span class="string">"git stash"</span></span><br><span class="line">9. 如果要丢弃一个没有被合并过的分支，可以通过 <span class="string">"git branch -D &lt;name&gt;"</span> 强行删除。</span><br><span class="line">10. 多人协作：</span><br><span class="line">   - 查看远程库信息，使用 <span class="string">"git remote -v"</span>；</span><br><span class="line">   - 本地新建的分支如果不推送到远程，对其他人就是不可见的；</span><br><span class="line">   - 从本地推送分支，使用 <span class="string">"git push origin branch-name"</span>，如果推送失败，先用 <span class="string">"git pull"</span> 抓取远程的新提交；</span><br><span class="line">   - 在本地创建和远程分支对应的分支，使用 <span class="string">"git checkout -b branch-name origin/branch-name"</span>，本地和远程分支的名称最好一致；</span><br><span class="line">   - 建立本地分支和远程分支的关联，使用 <span class="string">"git branch --set-upstream branch-name origin/branch-name"</span>；</span><br><span class="line">   - 从远程抓取分支，使用 <span class="string">"git pull"</span>，如果有冲突，要先处理冲突。</span><br></pre></td></tr></table></figure><a id="more"></a>

<h4 id="🌼-创建Git仓库"><a href="#🌼-创建Git仓库" class="headerlink" title="🌼. 创建Git仓库"></a>🌼. 创建Git仓库</h4><p>首先创建Git仓库，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。 </p>
<ol>
<li>在所需要git的文件夹内建立仓库：<ul>
<li>进入到目标文件夹</li>
<li>执行： <code>git init</code></li>
</ul>
</li>
<li>将文件放到git仓库：<ul>
<li>用命令 <code>git add test.py</code>告诉git，把文件添加到仓库。</li>
<li>用命令 <code>git commit -m &quot;xxx&quot;</code>告诉git，把文件提交到仓库。其中<code>&quot;xxx&quot;</code>输入的是本次提交的说明，可以输入任意内容，但最好有意义，方便从历史记录里找到改动的记录。</li>
</ul>
</li>
<li>为什么Git添加文件需要<code>add</code>，<code>commit</code>一共两步呢？因为<code>commit</code>可以一次提交很多文件，所以你可以多次add不同的文件，比如：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add file1.txt</span><br><span class="line">git add file2.txt file3.txt</span><br><span class="line">git commit -m <span class="string">"add 3 files."</span></span><br></pre></td></tr></table></figure>
<h4 id="🌼-修改文件并提交"><a href="#🌼-修改文件并提交" class="headerlink" title="🌼. 修改文件并提交"></a>🌼. 修改文件并提交</h4><p>修改<code>test.py</code>文件内容为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">a = 1</span><br></pre></td></tr></table></figure>
<p>运行 <code>git status</code>查看结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">位于分支 master</span><br><span class="line">尚未暂存以备提交的变更：</span><br><span class="line">  （使用 <span class="string">"git add &lt;文件&gt;..."</span> 更新要提交的内容）</span><br><span class="line">  （使用 <span class="string">"git checkout -- &lt;文件&gt;..."</span> 丢弃工作区的改动）</span><br><span class="line"></span><br><span class="line">    修改：     test.py</span><br><span class="line"></span><br><span class="line">修改尚未加入提交（使用 <span class="string">"git add"</span> 和/或 <span class="string">"git commit -a"</span>）</span><br></pre></td></tr></table></figure>
<p><code>git status</code>命令可以让我们时刻掌握仓库当前的状态，上面的命令输出告诉我们，<code>test.py</code>被修改过了，但还没有准备提交的修改。</p>
<p>用<code>git diff</code>命令可以查看我们对文件做进行修改的内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git diff</span><br><span class="line">diff --git a/test.py b/test.py</span><br><span class="line">index e69de29..1337a53 100644</span><br><span class="line">--- a/test.py</span><br><span class="line">+++ b/test.py</span><br><span class="line">@ -0,0 +1 @@</span><br><span class="line">+a = 1</span><br></pre></td></tr></table></figure>
<p>然后将<code>test.py</code>提交到仓库:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add test.py</span><br><span class="line">$ git commit -m <span class="string">"修改 a=1"</span></span><br></pre></td></tr></table></figure>
<p>提交后，我们再用<code>git status</code>命令看看仓库的当前状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">位于分支 master</span><br><span class="line">无文件要提交，干净的工作区</span><br></pre></td></tr></table></figure>
<p>Git告诉我们当前没有需要提交的修改，而且，工作目录是干净的。</p>
<h4 id="🌼-版本回退"><a href="#🌼-版本回退" class="headerlink" title="🌼. 版本回退"></a>🌼. 版本回退</h4><p>在之前的几次修改中，我一共提交了三个版本，用<code>git log</code>查看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --pretty=oneline</span><br><span class="line">4676b30e64d651522d8f1caf6722267eba7ad13b 修改2</span><br><span class="line">2e79bb499e48367e070d2eeae7a599504f8eac67 修改 a=1</span><br><span class="line">909ebc275138015313a9c652ef6c30e0e438fcc9 新建文件</span><br></pre></td></tr></table></figure>
<p>其中：一大串类似<code>4676b30e...</code>的是<code>commit id</code>（版本号）<br>新建文件：（空）<br>修改a=1： a=1<br>修改2： a=2 b=3</p>
<p>现在，将<code>test.py</code>会退到上一个版本：</p>
<p>首先，Git必须知道当前版本是哪个版本，在Git中，用<code>HEAD</code>表示当前版本，也就是最新的提交<code>4676b30...</code>，上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个<code>^</code>比较容易数不过来，所以写成<code>HEAD~100</code>。</p>
<p>现在，我们要把当前版本<code>修改2</code>回退到上一个版本<code>修改a=1</code>，就可以使用<code>git reset</code>命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br><span class="line">HEAD 现在位于 2e79bb4 修改 a=1</span><br></pre></td></tr></table></figure>
<p>看看<code>test.py</code>的内容是不是版本<code>修改a=1</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat test.py</span><br><span class="line">a = 1</span><br></pre></td></tr></table></figure>
<p>果然被还原了。</p>
<p><code>git log</code>查看版本库状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --pretty=oneline</span><br><span class="line">2e79bb499e48367e070d2eeae7a599504f8eac67 修改 a=1</span><br><span class="line">909ebc275138015313a9c652ef6c30e0e438fcc9 新建文件</span><br></pre></td></tr></table></figure>
<p>我们发现<code>修改2</code>不见了。这就相当于我们回到过去，用<code>git log</code>无法查看未来。所以要查看未来要用<code>git reflog</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">2e79bb4 HEAD@&#123;0&#125;: reset: moving to HEAD^</span><br><span class="line">4676b30 HEAD@&#123;1&#125;: commit: 修改2</span><br><span class="line">2e79bb4 HEAD@&#123;2&#125;: commit: 修改 a=1</span><br><span class="line">909ebc2 HEAD@&#123;3&#125;: commit (initial): 新建文件</span><br></pre></td></tr></table></figure>
<p>如果想回到未来，就执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset --hard 4676b30 (commit id)</span><br></pre></td></tr></table></figure>
<p>看看<code>test.py</code>的内容是不是版本<code>修改2</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat test.py</span><br><span class="line">a = 2</span><br><span class="line">b = 3</span><br></pre></td></tr></table></figure>
<p>比如我现在在工作区中新建一个<code>test3.py</code>,然后修改<code>test.py</code>和<code>test2.py</code>的内容，然后将这三个文件都<code>git add</code>到stage区，然后一次性<code>git commit</code>到<code>master</code>区。现在<code>git log</code>如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --pretty=oneline</span><br><span class="line">d142268223521c9f9c73c232793a7b10e0591f1a 测试</span><br><span class="line">6efac73f38c50d6f5cd7b8f3bd09458a5465750c understand how stage works</span><br><span class="line">4676b30e64d651522d8f1caf6722267eba7ad13b 修改2</span><br><span class="line">2e79bb499e48367e070d2eeae7a599504f8eac67 修改a=1</span><br><span class="line">909ebc275138015313a9c652ef6c30e0e438fcc9 新建文件</span><br></pre></td></tr></table></figure>
<p>然后我将版本回退到<code>understand how stage works</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br><span class="line">HEAD 现在位于 6efac73 understand how stage works</span><br></pre></td></tr></table></figure>
<p>此时，工作区中<code>test3.py</code>文件就不见了，然后<code>test.py</code>和<code>test2.py</code>中的内容都会回退到<code>understand how stage works</code>版本。</p>
<p><strong>也就是说，回退版本，不是对某个文件回退版本，而是对你这一次commit的所有文件进行版本回退</strong></p>
<h4 id="🌼-暂存区"><a href="#🌼-暂存区" class="headerlink" title="🌼. 暂存区"></a>🌼. 暂存区</h4><p>工作区就是我们能看到的文件；版本库就是<code>.git</code>文件夹<br>Git的版本库里存了很多东西，其中最重要的就是称为<code>stage</code>的暂存区，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code>。</p>
<p><img src="/images/git/0.jpg" alt="img"></p>
<p>前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：<br>第一步是用<code>git add</code>把文件添加进去，实际上就是把文件修改添加到暂存区；<br>第二步是用<code>git commit</code>提交更改，实际上就是把暂存区的所有内容提交到当前分支。<br>可以简单理解为，<strong>需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</strong></p>
<p>举例说明：</p>
<ol>
<li><p>先对<code>readme.txt</code>做个修改，比如加上一行内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后，在工作区新增一个<code>LICENSE</code>文本文件（内容随便写）。</p>
</li>
</ol>
<p>先用<code>git status</code>查看一下状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">	modified:   readme.txt</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line"></span><br><span class="line">	LICENSE</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br></pre></td></tr></table></figure>
<p>Git非常清楚地告诉我们，<code>readme.txt</code>被修改了，而<code>LICENSE</code>还从来没有被添加过，所以它的状态是<code>Untracked</code>。</p>
<p>现在，使用两次命令<code>git add</code>，把<code>readme.txt</code>和<code>LICENSE</code>都添加后，用<code>git status</code>再查看一下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">	new file:   LICENSE</span><br><span class="line">	modified:   readme.txt</span><br></pre></td></tr></table></figure>
<p>现在，暂存区的状态就变成这样了：</p>
<p><img src="/images/git/1.jpg" alt="img"></p>
<p>所以，<code>git add</code>命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行<code>git commit</code>就可以一次性把暂存区的所有修改提交到分支。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git commit -m <span class="string">"understand how stage works"</span></span><br><span class="line">[master e43a48b] understand how stage works</span><br><span class="line"> 2 files changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 LICENSE</span><br></pre></td></tr></table></figure>
<p>一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>
<p>现在版本库变成了这样，暂存区就没有任何内容了：</p>
<p><img src="/images/git/2.jpg" alt="img"></p>
<h4 id="🌼-撤销修改"><a href="#🌼-撤销修改" class="headerlink" title="🌼. 撤销修改"></a>🌼. 撤销修改</h4><p>1.命令<code>git checkout -- test.py</code>意思就是，把<code>test.py</code>文件在工作区的修改全部撤销，这里有两种情况：</p>
<ul>
<li>一种是<code>test.py</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</li>
<li>一种是<code>test.py</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</li>
</ul>
<p>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</p>
<p>2.如果你想把<code>test.py</code>文件在暂存区的修改撤销：<br>用命令<code>git reset HEAD</code>可以把暂存区的修改撤销掉（unstage），重新放回工作区：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git reset HEAD test.py</span><br></pre></td></tr></table></figure>
<p>然后在执行<code>git checkout -- test.py</code>就把工作区的修改删除了。</p>
<p><strong>总结</strong>：<br>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</p>
<p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD</code>，就回到了场景1，第二步按场景1操作。</p>
<h4 id="🌼-删除文件"><a href="#🌼-删除文件" class="headerlink" title="🌼. 删除文件"></a>🌼. 删除文件</h4><p>一般情况下，我们通常直接在文件管理器中把没用的文件删了，或者用rm命令删了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ rm test3.py</span><br></pre></td></tr></table></figure>
<p>这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，<code>git status</code>命令会立刻告诉你哪些文件被删除了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">位于分支 master</span><br><span class="line">尚未暂存以备提交的变更：</span><br><span class="line">  （使用 <span class="string">"git add/rm &lt;文件&gt;..."</span> 更新要提交的内容）</span><br><span class="line">  （使用 <span class="string">"git checkout -- &lt;文件&gt;..."</span> 丢弃工作区的改动）</span><br><span class="line"></span><br><span class="line">    删除：     test3.py</span><br><span class="line"></span><br><span class="line">修改尚未加入提交（使用 <span class="string">"git add"</span> 和/或 <span class="string">"git commit -a"</span>）</span><br></pre></td></tr></table></figure>
<p>现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令<code>git rm</code>删掉，并且<code>git commit</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git rm test3.py</span><br><span class="line">rm <span class="string">'test3.py'</span></span><br><span class="line">$ git commit -m <span class="string">"remove test3.py"</span></span><br><span class="line">[master 794e84a] remove test3.py</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> delete mode 100644 test3.py</span><br></pre></td></tr></table></figure>
<p>现在，文件就从版本库中被删除了。</p>
<p>另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout -- test3.py</span><br></pre></td></tr></table></figure>
<p><code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”.</p>
<p> 注意：从来没有被添加到版本库就被删除的文件，是无法恢复的！ </p>
<h4 id="🌼-分支管理"><a href="#🌼-分支管理" class="headerlink" title="🌼. 分支管理"></a>🌼. 分支管理</h4><p>分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。</p>
<p>现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。</p>
<h5 id="1-创建与合并分支"><a href="#1-创建与合并分支" class="headerlink" title="1. 创建与合并分支"></a>1. 创建与合并分支</h5><p>Git把每次提交都串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即<code>master</code>分支。<code>HEAD</code>严格来说不是指向提交，而是指向<code>master</code>，<code>master</code>才是指向提交的，所以，<code>HEAD</code>指向的就是当前分支。 </p>
<p>一开始的时候，<code>master</code>分支是一条线，Git用<code>master</code>指向最新的提交，再用<code>HEAD</code>指向<code>master</code>，就能确定当前分支，以及当前分支的提交点： </p>
<p><img src="/images/git/0.png" alt="img"></p>
<p>每次提交，<code>master</code>分支都会向前移动一步，这样，随着你不断提交，<code>master</code>分支的线也越来越长。</p>
<p>当我们创建新的分支，例如<code>dev</code>时，Git新建了一个指针叫<code>dev</code>，指向<code>master</code>相同的提交，再把<code>HEAD</code>指向<code>dev</code>，就表示当前分支在<code>dev</code>上：</p>
<p><img src="/images/git/1.png" alt="img"></p>
<p>你看，Git创建一个分支很快，因为除了增加一个<code>dev</code>指针，改改<code>HEAD</code>的指向，工作区的文件都没有任何变化！</p>
<p>不过，从现在开始，对工作区的修改和提交就是针对<code>dev</code>分支了，比如新提交一次后，<code>dev</code>指针往前移动一步，而<code>master</code>指针不变：</p>
<p><img src="/images/git/2.png" alt="img"></p>
<p>假如我们在<code>dev</code>上的工作完成了，就可以把<code>dev</code>合并到<code>master</code>上。Git怎么合并呢？最简单的方法，就是直接把<code>master</code>指向<code>dev</code>的当前提交，就完成了合并： </p>
<p><img src="/images/git/3.png" alt="img"></p>
<p>所以Git合并分支也很快！就改改指针，工作区内容也不变！</p>
<p>合并完分支后，甚至可以删除<code>dev</code>分支。删除<code>dev</code>分支就是把<code>dev</code>指针给删掉，删掉后，我们就剩下了一条<code>master</code>分支：</p>
<p><img src="/images/git/4.png" alt="img"></p>
<p><strong>下面开始实战：</strong></p>
<p>首先，我们创建<code>dev</code>分支，然后切换到<code>dev</code>分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout -b dev</span><br><span class="line">Switched to a new branch <span class="string">'dev'</span></span><br></pre></td></tr></table></figure>
<p><code>git checkout</code>命令加上<code>-b</code>参数表示创建并切换，相当于以下两条命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch dev</span><br><span class="line">$ git checkout dev</span><br><span class="line">Switched to branch <span class="string">'dev'</span></span><br></pre></td></tr></table></figure>
<p>然后，用<code>git branch</code>命令查看当前分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br></pre></td></tr></table></figure>
<p><code>git branch</code>命令会列出所有分支，当前分支前面会标一个<code>*</code>号。</p>
<p>然后，我们就可以在<code>dev</code>分支上正常提交，比如对<code>readme.txt</code>做个修改，加上一行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Creating a new branch is quick.</span><br></pre></td></tr></table></figure>
<p>然后提交：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m <span class="string">"branch test"</span></span><br><span class="line">[dev b17d20e] branch <span class="built_in">test</span></span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>
<p>现在，<code>dev</code>分支的工作完成，我们就可以切换回<code>master</code>分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br></pre></td></tr></table></figure>
<p>切换回<code>master</code>分支后，再查看一个<code>readme.txt</code>文件，刚才添加的内容不见了！因为那个提交是在<code>dev</code>分支上，而<code>master</code>分支此刻的提交点并没有变：</p>
<p><img src="/images/git/5.png" alt="img"></p>
<p>现在，我们把<code>dev</code>分支的工作成果合并到<code>master</code>分支上：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git merge dev</span><br><span class="line">Updating d46f35e..b17d20e</span><br><span class="line">Fast-forward</span><br><span class="line"> readme.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>
<p><code>git merge</code>命令用于合并指定分支到当前分支。合并后，再查看<code>readme.txt</code>的内容，就可以看到，和<code>dev</code>分支的最新提交是完全一样的。</p>
<p>注意到上面的<code>Fast-forward</code>信息，Git告诉我们，这次合并是“快进模式”，也就是直接把<code>master</code>指向<code>dev</code>的当前提交，所以合并速度非常快。</p>
<p>当然，也不是每次合并都能<code>Fast-forward</code>，我们后面会讲其他方式的合并。</p>
<p>合并完成后，就可以放心地删除<code>dev</code>分支了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch -d dev</span><br><span class="line">Deleted branch dev (was b17d20e).</span><br></pre></td></tr></table></figure>
<p>删除后，查看<code>branch</code>，就只剩下<code>master</code>分支了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br></pre></td></tr></table></figure>
<p>因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在<code>master</code>分支上工作效果是一样的，但过程更安全。</p>
<p><strong>switch：</strong></p>
<p>我们注意到切换分支使用<code>git checkout</code>，而前面讲过的撤销修改则是<code>git checkout --</code>，同一个命令，有两种作用，确实有点令人迷惑。</p>
<p>实际上，切换分支这个动作，用<code>switch</code>更科学。因此，最新版本的Git提供了新的<code>git switch</code>命令来切换分支：</p>
<p>创建并切换到新的<code>dev</code>分支，可以使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git switch -c dev</span><br></pre></td></tr></table></figure>
<p>直接切换到已有的<code>master</code>分支，可以使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git switch master</span><br></pre></td></tr></table></figure>
<p>使用新的<code>git switch</code>命令，比<code>git checkout</code>要更容易理解。</p>
<h5 id="2-解决冲突"><a href="#2-解决冲突" class="headerlink" title="2. 解决冲突"></a>2. 解决冲突</h5><p>人生不如意之事十之八九，合并分支往往也不是一帆风顺的。</p>
<p>准备新的<code>feature1</code>分支，继续我们的新分支开发：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout -b feature1</span><br><span class="line">Switched to a new branch <span class="string">'feature1'</span></span><br></pre></td></tr></table></figure>
<p>修改<code>readme.txt</code>最后一行，改为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Creating a new branch is quick AND simple.</span><br></pre></td></tr></table></figure>
<p>在<code>feature1</code>分支上提交：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add readme.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m <span class="string">"AND simple"</span></span><br><span class="line">[feature1 14096d0] AND simple</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>
<p>切换到<code>master</code>分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br><span class="line">Your branch is ahead of <span class="string">'origin/master'</span> by 1 commit.</span><br><span class="line">  (use <span class="string">"git push"</span> to publish your <span class="built_in">local</span> commits)</span><br></pre></td></tr></table></figure>
<p>Git还会自动提示我们当前<code>master</code>分支比远程的<code>master</code>分支要超前1个提交。</p>
<p>在<code>master</code>分支上把<code>readme.txt</code>文件的最后一行改为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Creating a new branch is quick &amp; simple.</span><br></pre></td></tr></table></figure>
<p>提交：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m <span class="string">"&amp; simple"</span></span><br><span class="line">[master 5dc6824] &amp; simple</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>
<p>现在，<code>master</code>分支和<code>feature1</code>分支各自都分别有新的提交，变成了这样：</p>
<p><img src="/images/git/6.png" alt="img"></p>
<p>这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git merge feature1</span><br><span class="line">Auto-merging readme.txt</span><br><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> readme.txt</span><br><span class="line">Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br></pre></td></tr></table></figure>
<p>果然冲突了！Git告诉我们，<code>readme.txt</code>文件存在冲突，必须手动解决冲突后再提交。<code>git status</code>也可以告诉我们冲突的文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of <span class="string">'origin/master'</span> by 2 commits.</span><br><span class="line">  (use <span class="string">"git push"</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line"></span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts and run <span class="string">"git commit"</span>)</span><br><span class="line">  (use <span class="string">"git merge --abort"</span> to abort the merge)</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to mark resolution)</span><br><span class="line"></span><br><span class="line">	both modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br></pre></td></tr></table></figure>
<p>我们可以直接查看readme.txt的内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">Creating a new branch is quick &amp; simple.</span><br><span class="line">=======</span><br><span class="line">Creating a new branch is quick AND simple.</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1</span><br></pre></td></tr></table></figure>
<p>Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容，我们修改如下后保存：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Creating a new branch is quick and simple.</span><br></pre></td></tr></table></figure>
<p>再提交：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m <span class="string">"conflict fixed"</span></span><br><span class="line">[master cf810e4] conflict fixed</span><br></pre></td></tr></table></figure>
<p>现在，<code>master</code>分支和<code>feature1</code>分支变成了下图所示：</p>
<p><img src="/images/git/7.png" alt="img"></p>
<p>用带参数的<code>git log</code>也可以看到分支的合并情况：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   cf810e4 (HEAD -&gt; master) conflict fixed</span><br><span class="line">|\  </span><br><span class="line">| * 14096d0 (feature1) AND simple</span><br><span class="line">* | 5dc6824 &amp; simple</span><br><span class="line">|/  </span><br><span class="line">* b17d20e branch <span class="built_in">test</span></span><br><span class="line">* d46f35e (origin/master) remove test.txt</span><br><span class="line">* b84166e add test.txt</span><br><span class="line">* 519219b git tracks changes</span><br><span class="line">* e43a48b understand how stage works</span><br><span class="line">* 1094adb append GPL</span><br><span class="line">* e475afc add distributed</span><br><span class="line">* eaadf4e wrote a readme file</span><br></pre></td></tr></table></figure>
<p>最后，删除<code>feature1</code>分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch -d feature1</span><br><span class="line">Deleted branch feature1 (was 14096d0).</span><br></pre></td></tr></table></figure>
<p>工作完成。</p>
<h5 id="3-分支策略"><a href="#3-分支策略" class="headerlink" title="3. 分支策略"></a>3. 分支策略</h5><p>在实际开发中，我们应该按照几个基本原则进行分支管理：</p>
<p>首先，<code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p>
<p>那在哪干活呢？干活都在<code>dev</code>分支上，也就是说，<code>dev</code>分支是不稳定的，到某个时候，比如1.0版本发布时，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布1.0版本；</p>
<p>你和你的小伙伴们每个人都在<code>dev</code>分支上干活，每个人都有自己的分支，时不时地往<code>dev</code>分支上合并就可以了。</p>
<p>所以，团队合作的分支看起来就像这样：</p>
<p><img src="/images/git/8.png" alt="img"></p>
<h5 id="4-git-stash-暂存分支内容"><a href="#4-git-stash-暂存分支内容" class="headerlink" title="4. git stash 暂存分支内容"></a>4. git stash 暂存分支内容</h5><p>软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。</p>
<p>当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支<code>issue-101</code>来修复它，但是，等等，当前正在<code>dev</code>上进行的工作还没有提交：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">	new file:   hello.py</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">	modified:   readme.txt</span><br></pre></td></tr></table></figure>
<p>并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？<strong>为什么不能直接新建一个分支去修复bug？ 总的来说，就是，在分支下进行的工作，如果不commit的话，回到master，就会显示出你在分支下你添加的工作。这个时候，你在master下修改完bug提交后，正在分支进行的工作也会提交了。为了避免这个情况，你就在分支下，git stash将工作隐藏，这个时候，切换到master时候，修改了bug，提交。分支的内容不会被提交上去。git stash还有一个作用，就是一些情况下，不提交就切换分支，会切换失败，贮藏一下再切换，就没问题了 </strong></p>
<p>幸好，Git还提供了一个<code>stash</code>功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git stash</span><br><span class="line">Saved working directory and index state WIP on dev: f52c633 add merge</span><br></pre></td></tr></table></figure>
<p>现在，用<code>git status</code>查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。</p>
<p>首先确定要在哪个分支上修复bug，假定需要在<code>master</code>分支上修复，就从<code>master</code>创建临时分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br><span class="line">Your branch is ahead of <span class="string">'origin/master'</span> by 6 commits.</span><br><span class="line">  (use <span class="string">"git push"</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line"></span><br><span class="line">$ git checkout -b issue-101</span><br><span class="line">Switched to a new branch <span class="string">'issue-101'</span></span><br></pre></td></tr></table></figure>
<p>现在修复bug，需要把“Git is free software …”改为“Git is a free software …”，然后提交：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m <span class="string">"fix bug 101"</span></span><br><span class="line">[issue-101 4c805e2] fix bug 101</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>
<p>修复完成后，切换到<code>master</code>分支，并完成合并，最后删除<code>issue-101</code>分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br><span class="line">Your branch is ahead of <span class="string">'origin/master'</span> by 6 commits.</span><br><span class="line">  (use <span class="string">"git push"</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line"></span><br><span class="line">$ git merge --no-ff -m <span class="string">"merged bug fix 101"</span> issue-101</span><br><span class="line">Merge made by the <span class="string">'recursive'</span> strategy.</span><br><span class="line"> readme.txt | 2 +-</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>
<p>太棒了，原计划两个小时的bug修复只花了5分钟！现在，是时候接着回到<code>dev</code>分支干活了！</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout dev</span><br><span class="line">Switched to branch <span class="string">'dev'</span></span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>
<p>工作区是干净的，刚才的工作现场存到哪去了？用<code>git stash list</code>命令看看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on dev: f52c633 add merge</span><br></pre></td></tr></table></figure>
<p>工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：</p>
<p>一是用<code>git stash apply</code>恢复，但是恢复后，stash内容并不删除，你需要用<code>git stash drop</code>来删除；</p>
<p>另一种方式是用<code>git stash pop</code>，恢复的同时把stash内容也删了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git stash pop</span><br><span class="line">On branch dev</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">	new file:   hello.py</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">	modified:   readme.txt</span><br><span class="line"></span><br><span class="line">Dropped refs/stash@&#123;0&#125; (5d677e2ee266f39ea296182fb2354265b91b3b2a)</span><br></pre></td></tr></table></figure>
<p>再用<code>git stash list</code>查看，就看不到任何stash内容了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git stash list</span><br></pre></td></tr></table></figure>
<p>你可以多次stash，恢复的时候，先用<code>git stash list</code>查看，然后恢复指定的stash，用命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git stash apply stash@&#123;0&#125;</span><br></pre></td></tr></table></figure>
<p>在master分支上修复了bug后，我们要想一想，dev分支是早期从master分支分出来的，所以，这个bug其实在当前dev分支上也存在。</p>
<p>那怎么在dev分支上修复同样的bug？重复操作一次，提交不就行了？</p>
<p>有木有更简单的方法？</p>
<p>有！</p>
<p>同样的bug，要在dev上修复，我们只需要把<code>4c805e2 fix bug 101</code>这个提交所做的修改“复制”到dev分支。注意：我们只想复制<code>4c805e2 fix bug 101</code>这个提交所做的修改，并不是把整个master分支merge过来。</p>
<p>为了方便操作，Git专门提供了一个<code>cherry-pick</code>命令，让我们能复制一个特定的提交到当前分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line">$ git cherry-pick 4c805e2</span><br><span class="line">[master 1d4b803] fix bug 101</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>
<p>Git自动给dev分支做了一次提交，注意这次提交的commit是<code>1d4b803</code>，它并不同于master的<code>4c805e2</code>，因为这两个commit只是改动相同，但确实是两个不同的commit。用<code>git cherry-pick</code>，我们就不需要在dev分支上手动再把修bug的过程重复一遍。</p>
<p><img src="/images/git/6.png" alt="img"></p>
<h5 id="5-多人协作"><a href="#5-多人协作" class="headerlink" title="5. 多人协作"></a>5. 多人协作</h5><p>当你从远程仓库克隆时，实际上Git自动把本地的<code>master</code>分支和远程的<code>master</code>分支对应起来了，并且，远程仓库的默认名称是<code>origin</code>。</p>
<p>要查看远程库的信息，用<code>git remote</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git remote</span><br><span class="line">origin</span><br></pre></td></tr></table></figure>
<p>或者，用<code>git remote -v</code>显示更详细的信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  git@github.com:michaelliao/learngit.git (fetch)</span><br><span class="line">origin  git@github.com:michaelliao/learngit.git (push)</span><br></pre></td></tr></table></figure>
<p>上面显示了可以抓取和推送的<code>origin</code>的地址。如果没有推送权限，就看不到push的地址。</p>
<p><strong>推送分支</strong></p>
<p>推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure>
<p>如果要推送其他分支，比如<code>dev</code>，就改成：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push origin dev</span><br></pre></td></tr></table></figure>
<p>但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？</p>
<ul>
<li><code>master</code>分支是主分支，因此要时刻与远程同步；</li>
<li><code>dev</code>分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</li>
<li>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</li>
<li>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</li>
</ul>
<p>总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！</p>
<p><strong>抓取分支</strong></p>
<p>多人协作时，大家都会往<code>master</code>和<code>dev</code>分支上推送各自的修改。</p>
<p>现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git@github.com:michaelliao/learngit.git</span><br><span class="line">Cloning into <span class="string">'learngit'</span>...</span><br><span class="line">remote: Counting objects: 40, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (21/21), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 40 (delta 14), reused 40 (delta 14), pack-reused 0</span><br><span class="line">Receiving objects: 100% (40/40), <span class="keyword">done</span>.</span><br><span class="line">Resolving deltas: 100% (14/14), <span class="keyword">done</span>.</span><br></pre></td></tr></table></figure>
<p>当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的<code>master</code>分支。不信可以用<code>git branch</code>命令看看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br></pre></td></tr></table></figure>
<p>现在，你的小伙伴要在<code>dev</code>分支上开发，就必须创建远程<code>origin</code>的<code>dev</code>分支到本地，于是他用这个命令创建本地<code>dev</code>分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout -b dev origin/dev</span><br></pre></td></tr></table></figure>
<p>现在，他就可以在<code>dev</code>上继续修改，然后，时不时地把<code>dev</code>分支<code>push</code>到远程：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add env.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m <span class="string">"add env"</span></span><br><span class="line">[dev 7a5e5dd] add env</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 env.txt</span><br><span class="line"></span><br><span class="line">$ git push origin dev</span><br><span class="line">Counting objects: 3, <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (2/2), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (3/3), 308 bytes | 308.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line">   f52c633..7a5e5dd  dev -&gt; dev</span><br></pre></td></tr></table></figure>
<p>你的小伙伴已经向<code>origin/dev</code>分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat env.txt</span><br><span class="line">env</span><br><span class="line"></span><br><span class="line">$ git add env.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m <span class="string">"add new env"</span></span><br><span class="line">[dev 7bd91f1] add new env</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 env.txt</span><br><span class="line"></span><br><span class="line">$ git push origin dev</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> ! [rejected]        dev -&gt; dev (non-fast-forward)</span><br><span class="line">error: failed to push some refs to <span class="string">'git@github.com:michaelliao/learngit.git'</span></span><br><span class="line">hint: Updates were rejected because the tip of your current branch is behind</span><br><span class="line">hint: its remote counterpart. Integrate the remote changes (e.g.</span><br><span class="line">hint: <span class="string">'git pull ...'</span>) before pushing again.</span><br><span class="line">hint: See the <span class="string">'Note about fast-forwards'</span> <span class="keyword">in</span> <span class="string">'git push --help'</span> <span class="keyword">for</span> details.</span><br></pre></td></tr></table></figure>
<p>推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用<code>git pull</code>把最新的提交从<code>origin/dev</code>抓下来，然后，在本地合并，解决冲突，再推送：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">There is no tracking information <span class="keyword">for</span> the current branch.</span><br><span class="line">Please specify <span class="built_in">which</span> branch you want to merge with.</span><br><span class="line">See git-pull(1) <span class="keyword">for</span> details.</span><br><span class="line"></span><br><span class="line">    git pull &lt;remote&gt; &lt;branch&gt;</span><br><span class="line"></span><br><span class="line">If you wish to <span class="built_in">set</span> tracking information <span class="keyword">for</span> this branch you can <span class="keyword">do</span> so with:</span><br><span class="line"></span><br><span class="line">    git branch --<span class="built_in">set</span>-upstream-to=origin/&lt;branch&gt; dev</span><br></pre></td></tr></table></figure>
<p><code>git pull</code>也失败了，原因是没有指定本地<code>dev</code>分支与远程<code>origin/dev</code>分支的链接，根据提示，设置<code>dev</code>和<code>origin/dev</code>的链接：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch --<span class="built_in">set</span>-upstream-to=origin/dev dev</span><br><span class="line">Branch <span class="string">'dev'</span> <span class="built_in">set</span> up to track remote branch <span class="string">'dev'</span> from <span class="string">'origin'</span>.</span><br></pre></td></tr></table></figure>
<p>再pull：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">Auto-merging env.txt</span><br><span class="line">CONFLICT (add/add): Merge conflict <span class="keyword">in</span> env.txt</span><br><span class="line">Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br></pre></td></tr></table></figure>
<p>这回<code>git pull</code>成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的<a href="http://www.liaoxuefeng.com/wiki/896043488029600/900004111093344" target="_blank" rel="noopener">解决冲突</a>完全一样。解决后，提交，再push：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git commit -m <span class="string">"fix env conflict"</span></span><br><span class="line">[dev 57c53ab] fix env conflict</span><br><span class="line"></span><br><span class="line">$ git push origin dev</span><br><span class="line">Counting objects: 6, <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (4/4), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (6/6), 621 bytes | 621.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">Total 6 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line">   7a5e5dd..57c53ab  dev -&gt; dev</span><br></pre></td></tr></table></figure>
<p>因此，多人协作的工作模式通常是这样：</p>
<ol>
<li>首先，可以试图用<code>git push origin</code>推送自己的修改；</li>
<li>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</li>
<li>如果合并有冲突，则解决冲突，并在本地提交；</li>
<li>没有冲突或者解决掉冲突后，再用<code>git push origin</code>推送就能成功！</li>
</ol>
<p>如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to  origin/</code>。</p>
<p>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p>
<h4 id="🌼-公司方法"><a href="#🌼-公司方法" class="headerlink" title="🌼. 公司方法"></a>🌼. 公司方法</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">push代码：</span><br><span class="line">    1. 先 <span class="string">"git checkout branch"</span> 到branch分支上</span><br><span class="line">    2. “git pull origin master”， 将origin的最新代码拉到master上面</span><br><span class="line">    3. “git checkout -b songge/name”, 新建一个分支，songge/name 是名字</span><br><span class="line">    4. 在新的分支上改自己的代码。</span><br><span class="line">    5. 改完之后 <span class="string">"git status"</span> 看一下。</span><br><span class="line">    6. <span class="string">"git add * * * "</span> 把需要的改动add上去，</span><br><span class="line">    7. <span class="string">"git commit -a "</span>gaidong<span class="string">" "</span> 提交改动。</span><br><span class="line">    8. 注意：错删的，就是不想改了的文件，直接 <span class="string">"git checkout -- wenjianming"</span> 就能恢复</span><br><span class="line">    9. <span class="string">"git log"</span> 查看历史提交</span><br><span class="line">    10. “git commit --amend” 在文件最前面加上 “[workflow] 后面就是songge/name”</span><br><span class="line">    11. <span class="string">"git push"</span>. 就行了</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/Git/" rel="tag"><i class="fa fa-tag"></i> Git</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
                <a href="/2019/11/08/LayerNorm-Σ╕Ä-BatchNorm/" rel="next" title="BatchNorm 与 LayerNorm">
                  <i class="fa fa-chevron-left"></i> BatchNorm 与 LayerNorm
                </a>
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
                <a href="/2019/11/13/C++τ▒╗/" rel="prev" title="C++类">
                  C++类 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="gitalk-container"></div>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#🍬-总结"><span class="nav-number">1.</span> <span class="nav-text">🍬. 总结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#🌼-创建Git仓库"><span class="nav-number">2.</span> <span class="nav-text">🌼. 创建Git仓库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#🌼-修改文件并提交"><span class="nav-number">3.</span> <span class="nav-text">🌼. 修改文件并提交</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#🌼-版本回退"><span class="nav-number">4.</span> <span class="nav-text">🌼. 版本回退</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#🌼-暂存区"><span class="nav-number">5.</span> <span class="nav-text">🌼. 暂存区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#🌼-撤销修改"><span class="nav-number">6.</span> <span class="nav-text">🌼. 撤销修改</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#🌼-删除文件"><span class="nav-number">7.</span> <span class="nav-text">🌼. 删除文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#🌼-分支管理"><span class="nav-number">8.</span> <span class="nav-text">🌼. 分支管理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-创建与合并分支"><span class="nav-number">8.1.</span> <span class="nav-text">1. 创建与合并分支</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-解决冲突"><span class="nav-number">8.2.</span> <span class="nav-text">2. 解决冲突</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-分支策略"><span class="nav-number">8.3.</span> <span class="nav-text">3. 分支策略</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-git-stash-暂存分支内容"><span class="nav-number">8.4.</span> <span class="nav-text">4. git stash 暂存分支内容</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-多人协作"><span class="nav-number">8.5.</span> <span class="nav-text">5. 多人协作</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#🌼-公司方法"><span class="nav-number">9.</span> <span class="nav-text">🌼. 公司方法</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Alyssa"
      src="/images/toux.jpg">
  <p class="site-author-name" itemprop="name">Alyssa</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/alyssaasa" title="GitHub → https://github.com/alyssaasa" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/Alyssaasa" title="Weibo → https://weibo.com/Alyssaasa" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i>Weibo</a>
      </span>
  </div>


<script type="text/javascript">
     var alltags = document.getElementsByClassName('tag-cloud-tags');
     var tags = alltags[0].getElementsByTagName('a');
     for (var i = tags.length - 1; i >= 0; i--) {
       var r=Math.floor(Math.random()*75+130);
       var g=Math.floor(Math.random()*75+100);
       var b=Math.floor(Math.random()*75+80);
       tags[i].style.background = "rgb("+r+","+g+","+b+")";
     }
</script>

<style>
  .tag-cloud-tags{
    /*font-family: Helvetica, Tahoma, Arial;*/
    /*font-weight: 100;*/
    text-align: center;
    counter-reset: tags;
  }
  .tag-cloud-tags a{
    border-radius: 6px;
    padding-right: 5px;
    padding-left: 5px;
    margin: 8px 5px 10px 3px;
  }
  .tag-cloud-tags a:before{
    content: "🔖";
  }

  .tag-cloud-tags a:hover{
     box-shadow: 0px 5px 15px 0px rgba(0,0,0,.4);
     transform: scale(1.1);
     /*box-shadow: 10px 10px 15px 2px rgba(0,0,0,.12), 0 0 6px 0 rgba(104, 104, 105, 0.1);*/
     transition-duration: 0.15s;
  }

</style>

      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Alyssa</span>
</div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  




  <script src="/js/local-search.js"></script>













  

  
      
<script type="text/x-mathjax-config">

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', () => {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script>

    

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID: 'a0b09f47cc93396b2dd6',
      clientSecret: 'bdf8c7211c890d37071003e98dd9879483be6512',
      repo: 'alyssaasa.github.io',
      owner: 'alyssaasa',
      admin: ['alyssaasa'],
      id: '27fcc839160e8794a3b36c355feb816a',
        language: 'zh-CN',
      distractionFreeMode: 'true'
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
</script>

</body>
</html>
